<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" []>
<chapter>
  <title>Instalación</title>
  <para>El capítulo de instalación proporciona información sobre cómo instalar DHIS 2 en diversos contextos, incluidos un servidor central online, una red local offline, una aplicación independiente y un paquete autocontenido denominado DHIS 2 Live.</para>
  <para>DHIS 2 funciona en toda plataforma para la cual exista una versión 6 o superior del Entorno de Ejecución de Java (Java Runtime Environment), lo que incluye los sistemas operativos más populares como son Windows, Linux y Mac. DHIS 2 funciona con sistemas de bases de datos relacionales como PostgreSQL, MySQL, H2 y Derby. DHIS 2 está empaquetado como un fichero estándar Java Web Archive (fichero WAR) y por tanto se ejecuta en cualquier contenedor Servlet como Tomcat o Jetty.</para>
  <para>El equipo DHIS 2 recomienda el sistema operativo Ubuntu 12.04 LTS, el sistema de base de datos PostgreSQL y el contenedor Servlet Tomcat como el entorno preferido para las instalaciones en servidor. Los sistemas mencionados pueden considerarse líderes de mercado en sus respectivos dominios y han sido probados intensivamente durante muchos años.</para>
  <para>Este capítulo ofrece una guía para montar la citada pila de tecnologías (Ubuntu-PostgreSQL-Tomcat). Sin embargo, esta guía debe leerse como un itinerario para montar y poner en marcha DHIS 2, y no como una documentación exhaustiva sobre el entorno mencionado. Para una lectura en profundidad, recomendamos seguir la documentación oficial de Ubuntu, PostgreSQL y Tomcat.</para>
  <section>
    <title>Montaje del servidor</title>
    <para>Esta sección describe cómo montar una instancia de servidor de DHIS 2 en Ubuntu 12.04 64 bit con PostgreSQL como sistema de base de datos y con Tomcat como contenedor Servlet. El término <emphasis role="italic">invocar</emphasis> indica la ejecución de un determinado comando en el terminal.</para>
    <para>Para un servidor nacional los requisitos hardware son un procesador quad-core 2GHz o superior y 12GB de RAM o superior. Nótese que se requiere un sistema operativo de 64 bits para utilizar más de 4 GB de RAM, por lo que se recomienda la edición Ubuntu 12.04 de 64 bits.</para>
    <para>En esta guía asumiremos que 4 GB se asignan a PostgreSQL y 7GB de RAM se asignan a Tomcat. <emphasis role="italic">¡Si estás utilizando una configuración distinta por favor ajusta los valores sugeridos en consecuencia!</emphasis>. Los pasos que marcaremos como <emphasis role="italic">opcional</emphasis>, como el paso de ajuste de rendimiento, pueden realizarse en un momento posterior.</para>
    <para><emphasis role="bold">Crear nuevo usuario (opcional)</emphasis></para>
    <para>Tal vez queramos crear un usuario dedicado para ejecutar DHIS - no es recomendable ejecutarlo como usuario root. Creamos un nuevo usuario llamado dhis invocando <code>useradd -d /home/dhis -m dhis -s /bin/bash</code> </para>
    <para>A continuación habilitamos al usuario para realizar operaciones como root temporalmente invocando <code>adduser dhis admin</code> </para>  
    <para>Si no hay grupo admin en el sistema, crearemos dicho grupo primero invocando <code>groupadd admin</code></para>
    <para>Después invocamos <code>passwd dhis</code> para fijar la contraseña de esta nueva cuenta de usuario. Nos aseguraremos de poner una contraseña fuerte con al menos 15 caracteres aleatorios. </para>
    <para>Tal vez queramos deshabilitar el login remoto para la cuenta de root, logrando así mayor seguridad, invocando <code> sudo passwd -l root</code></para>
    <para><emphasis role="bold">Ajuste del núcleo del sistema operativo</emphasis></para>
    <para>Estas configuraciones son opcionales excepto para la configuración de la memoria compartida, que es un requisito para la asignación de memoria para PostgreSQL. Abrimos el fichero de configuración del núcleo o kernel invocando <code>sudo nano /etc/sysctl.conf</code>   Al final del fichero añadiremos las líneas siguientes y guardaremos el fichero.</para>
    <screen>kernel.shmmax = 1073741824
net.core.rmem_max = 8388608
net.core.wmem_max = 8388608</screen>
    <para>Hacemos que los cambios tengan efecto invocando <code>sudo sysctl -p</code></para>
    <para><emphasis role="bold">Instalar Java</emphasis></para>
    <para>Instalamos Java invocando lo siguiente:</para>
    <screen>sudo apt-get install openjdk-7-jdk

sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-openjdk/bin/java 1

sudo update-alternatives --set java /usr/lib/jvm/java-7-openjdk/bin/java</screen>
    <para>A continuación es importante chequear que la ruta de los binarios de Java es correcta, ya que puede cambiar de un sistema a otro, por ejemplo en sistemas AMD podríamos encontrar algo como <emphasis role="italic">../java-7-openjdk-amd64/..</emphasis>. Chequeamos a continuación que nuestra instalación está bien invocando <code>java -version</code></para>
    <para><emphasis role="bold">Instalar PostgreSQL</emphasis></para>
    <para>Instalamos PostgreSQL invocando <code>sudo apt-get install postgresql-9.1</code></para>
    <para>Cambiamos al usuario de postgres invocando <code>sudo su postgres</code>  </para>
    <para>Creaamos ahora un usuario sin privilegios llamado <emphasis role="italic">dhis</emphasis> invocando
        <code>createuser -SDRP dhis</code>   Introducimos una contraseña segura cuando aparece el prompt. Creamos una base de datos invocando <code>createdb -O dhis dhis2</code>   Regresamos a nuestra sesión de usuario invocando <code>exit</code>   </para>
        <para>Ahora ya tenemos un usuario PostgreSQL llamado <emphasis role="italic">dhis</emphasis> y una base de datos llamada <emphasis role="italic">dhis2</emphasis>.</para>
    <para>Continuamos ajustando el rendimiento abriendo el fichero siguiente invocando</para>
    <para><code>sudo nano /etc/postgresql/9.1/main/postgresql.conf</code></para>
    <para>y fijando las propiedades siguientes:</para>
    <para><code>shared_buffers = 512MB</code></para>
    <para>Esto determina cuánta memoria PostgreSQL puede utilizarse para almacenar datos de consultas. Se ajusta muy pequeña por defecto porque depende de la memoria compartida del núcleo, que es reducida en algunos sistemas operativos. </para>
    <para><code>effective_cache_size = 3500MB</code></para>
    <para>Es una estimación de cuánta memoria está disponible para almacenar (no para asignar) y es usada por PostgreSQL para determinar si un plan de consultas se adecuará a la memoria o no (aquí una configuración demasiado grande podría resultar en un comportamiento impredecible y lento).</para>
    <para><code>checkpoint_segments = 32</code></para>
    <para>PostgreSQL graba las nuevas transacciones en un fichero de log llamado WAL en segmentos de tamaño 16MB. Cuando se graba una cantidad de segmentos dada sucede un checkpoint. Configurar esta cifra en un valor mayor nos permite por tanto mejorar el rendimiento de sistemas de escritura pesada como DHIS 2.</para>
    <para><code>checkpoint_completion_target = 0.8</code></para>
    <para>Determina el porcentaje de segmentos completos antes de que aparezca un checkpoint. Fijar este número en un valor alto amplía por tanto la transcripción y reduce la sobrecarga de escritura promedio.</para>
    <para><code>wal_buffers = 4MB</code></para>
    <para>Fija la memoria utilizada para buffer durante el proceso de escritura WAL. Aumentar este valor puede mejorar el rendimiento en sistemas de escritura pesada.</para>
    <para><code>synchronous_commit = off</code></para>
    <para>Especifica si las asignaciones de transacción van a esperar a que se escriban los registros WAL en el disco antes de regresar al cliente o no. Fijar esto en off mejora el rendimiento considerablemente. También implica que habrá un pequeño retardo entre la transacción reportada con éxito al cliente y que esté realmente guardada, pero el estado de la base de datos no puede corromperse y es una buena alternativa en sistemas de producción intensiva y escritura pesada como DHIS 2.</para>
    <para><code>wal_writer_delay = 10000ms</code></para>
    <para>Especifica el retraso entre operaciones de escritura WAL. Fijar esto a un valor grande mejora el rendimiento en sistemas de escritura pesada ya que potencialmente pueden ejecutarse muchas operaciones de escritura en un único envío al disco.</para>
    <para>Reiniciar PostgreSQL invocando <code>sudo /etc/init.d/postgresql restart</code></para>
    <para><emphasis role="bold">Fijar la configuración de la base de datos</emphasis></para>
    <para>La información de conexión de la base de datos llega a DHIS 2 a través de un fichero de configuración llamado <emphasis role="italic">hibernate.properties</emphasis>. Creamos este fichero y lo guardamos en una ubicación adecuada. El fichero correspondiente al montaje anterior tiene las siguientes propiedades:</para>
    <para><screen>hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect
hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql:dhis2
hibernate.connection.username = dhis
hibernate.connection.password = xxxx
hibernate.hbm2ddl.auto = update</screen></para>
    <para>Un error frecuente es dejar un espacio en blanco después del último valor de propiedad - asegúrate de que no hay espacios en blanco al final de ninguna línea en este fichero. También debemos recordar que este fichero contiene la contraseña en claro de nuestra base de datos dhis2 de modo que deberemos protegerlo de accesos no autorizados. Para hacer esto invocamos <code>chmod 0600 hibernate.properties</code> que garantiza que solo el usuario dhis que es propietario del fichero puede leer o escribir en él.</para>
    <para><emphasis role="bold">Instalar Tomcat</emphasis></para>
    <para>Descarga la distribución binaria de Tomcat de <emphasis role="italic">http://tomcat.apache.org/download-70.cgi</emphasis>. Una herramienta útil para descargar ficheros desde la web es <emphasis role="italic">wget</emphasis>. Extraemos el fichero en una ubicación adecuada. Esta guía asume que hemos navegado al directorio root del fichero extraido.</para>
    <para>Limpiamos las aplicaciones web preinstaladas invocando <code>rm -rf webapps/*</code> Descargamos el último fichero WAR de DHIS 2 desde <emphasis role="italic"> http://dhis2.org/download</emphasis>, lo movemos al directorio <emphasis role="italic">webapps</emphasis> y lo renombramos como <emphasis role="italic">ROOT.war</emphasis></para>
    <para>Abrimos el fichero <emphasis role="italic">bin/setclasspath.sh</emphasis> y añadimos las líneas que siguen. Lo primero será fijar la ubicación de nuestro Java Runtime Environment, lo segundo será dedicar memoria a Tomcat y lo tercero será fijar la ubicación en la que DHIS 2 buscará el fichero de configuración <emphasis role="italic">hibernate.properties</emphasis>. Es importante aquí que chequeemos que la ruta a la ubicación del JDK es correcta. Notemos que deberemos ajustar esto a nuestro entorno:</para>
    <para><screen>export JAVA_HOME=&apos;/usr/lib/jvm/java-7-openjdk&apos;
export JAVA_OPTS=&apos;-Xmx6000m -Xms3000m -XX:MaxPermSize=800m -XX:PermSize=400m&apos;
export DHIS2_HOME=&apos;/home/dhis/config&apos;</screen></para>
    <para>Si necesitamos cambiar el <emphasis role="italic">puerto</emphasis> en el que Tomcat escucha las peticiones, podemos abrir el fichero de configuración de Tomcat <emphasis role="italic">/conf/server.xml</emphasis>, encontrar el elemento <emphasis role="italic">&lt;Connector&gt;</emphasis> que no está comentado y cambiar el valor de su atributo <emphasis role="italic">puerto</emphasis> por el número de puerto deseado.</para>
    <para>El log será nuestra primera fuente de información cuando queramos monitorear el comportamiento de Tomcat. Podemos ver fácilmente el log invocando <code>tail -f logs/catalina.out</code></para>
    <para><emphasis role="bold">Ejecutar DHIS 2</emphasis></para>
    <para>Para terminar haremos ejecutable el script de arranque invocando <code>chmod 755 bin/*</code>   Ahora podemos arrancar DHIs 2 invocando <code>bin/startup.sh</code>   Podemos monitorear el log invocando <code>tail -f logs/catalina.out</code>   Podemos detener DHIS 2 invocando <code>bin/shutdown.sh</code>   Finalemente, asumiendo que el fichero WAR se llama ahora ROOT.war, podemos acceder a nuestra instancia DHIS a través del navegador web en <emphasis role="italic"> http://localhost:8080</emphasis>.</para>
  </section>

  <section>
    <title>Configuración de proxy inverso</title>
    <para>Un proxy inverso es un servidor proxy que funciona en representación de un servidor. Utilizar un proxy inverso combinado con un contenedor Servlet es algo opcional en DHIS, pero tiene numerosas ventajas:</para>
    <itemizedlist>
      <listitem>
        <para>Las peticiones pueden mapearse y ser pasadas a múltiples contenedores Servlet - esto hace el sistema más flexible y facilita la ejecución de múltiples instancias de DHIS en el mismo servidor. También posibilita que cambiemos la configuración interna del servidor sin que ello repercuta a los clientes.</para>
      </listitem>
      <listitem>
        <para>La aplicación DHIS puede funcionar como un usuario no root en un puerto distinto del 80, lo que limita las consecuencias de un ataque de suplantación de sesión.</para>
      </listitem>
      <listitem>
        <para>El proxy inverso puede funcionar como un solo servidor SSL y podemos configurarlo para inspeccionar las peticiones en busca de contenido malicioso, peticiones y respuestas de log y también proporcionar mensajes de error no sensibles mejorando la seguridad en general.</para>
      </listitem>
    </itemizedlist>
    <section>
      <title>Instalación básica de nginx</title>
      <para>Recomendamos utilizar nginx  (http://wiki.nginx.org) como proxy inverso debido a su reducida huella de memoria y a su facilidad de uso. Para obtener la versión más actualizada recomendamos su instalación desde las fuentes:</para>
      <screen>sudo apt-get install make gcc libpcre3 libpcre3-dev zlibc zlib1g zlib1g-dev libssl-dev openssl</screen>
      <para><screen>wget http://nginx.org/download/nginx-1.0.14.tar.gz
tar xzvf nginx-1.0.14.tar.gz
cd nginx-1.0.14
/configure --with-http_ssl_module
make
sudo make install
</screen></para>
      <para>Ahora podemos iniciar y detener nginx con los comandos siguientes:</para>
      <para><screen>sudo /usr/local/nginx/sbin/nginx
sudo /usr/local/nginx/sbin/nginx -s stop</screen></para>
      <para>Ahora que hemos instalado nginx continuaremos configurando el proxy regular de peticiones a nuestra instancia de Tomcat, que asumimos que se ejecuta en <emphasis role="italic">http://localhost:8080</emphasis>. Para configurar nginx podemos abrir el fichero de configuración invocando:</para>
      <para><code>sudo nano /usr/local/nginx/conf/nginx.conf</code></para>
      <para>La configuración de nginx se monta en torno a una jerarquía de bloques que incluye http, servidor y ubicación, donde cada bloque hereda los parámetros configurados en los bloques padre. El código siguiente configura nginx para pasar por proxy (redireccionar) las peticiones del puerto 80 (que es el puerto que nginx escucha por defecto) a nuestra instancia de Tomcat. Con esto también conseguimos que nginx sirva peticiones de contenido estático como son javascript, hojas de estilo e imágenes, e instruya a los clientes para guardarlas en caché durante 4 días, de modo que se reduce la carga de Tomcat y se mejora el rendimiento en general. Por eso, añadiremos la configuración siguiente en el fichero nginx.conf:</para>
      <para><screen><![CDATA[server {
  listen               80;
  client_max_body_size 10M; # Default 1M, change it!

  # Serve static content
  # Root points to your DHIS webapp location, update it!

  location ~ (\.js$|\.css$|\.gif$|\.woff$|\.ttf$|\.eot$|^/images/|^/icons/|^/dhis-web-commons/.*\.png$) {
    root     /home/dhis/tomcat/webapps/ROOT;
    expires  4d;
  } 

  # Proxy pass to servlet container

  location / {
    proxy_pass        http://localhost:8080/;
    proxy_redirect    off;
    proxy_set_header  Host            $host;
    proxy_set_header  X-Real-IP       $remote_addr;
    proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}]]></screen></para>
      <para>Ahora podemos acceder a nuestra instancia DHIS en <emphasis role="italic">http://localhost</emphasis>. Ahora que el proxy inverso ya está funcionando, podemos mejorar la seguridad del sistema haciendo que Tomcat solo escuche conexiones locales. En el fichero <emphasis role="italic">/conf/server.xml</emphasis> podemos añadir un atributo de dirección: <emphasis role="italic">address</emphasis>, con el valor de <emphasis role="italic">localhost</emphasis> al elemento Connector de HTTP 1.1 de la siguiente manera:</para>
      <para><screen>&lt;Connector address=&quot;localhost&quot; protocol=&quot;HTTP/1.1&quot; ... &gt;</screen></para>
      <important>
        <para>El bloque de ubicación para contenido estático es esencial, ya que los navegadores web no cachean contenido estático por defecto sobre SSL. Solo cachean este tipo de contenido en el lado del cliente si el servidor web lo indica explícitamente.</para>
      </important>
    </section>


    <section>
      <title>Habilitando SSL en nginx</title>
      <para>Para mejorar la seguridad es recomendable configurar el servidor donde funciona DHIS para que se comunique con los clientes mediante una conexión encriptada y para identificarse con los clientes mediante un certificado válido. Esto es posible utilizando SSL, que es un protocolo de comunicación criptográfica que funciona sobre TCP/IP.</para>
      <para>Para configurar nginx de manera que utilice SSL, necesitaremos un certificado SSL apropiado emitido por un proveedor SSL. El coste del certificado depende enormemente de la fortaleza del encriptado. Un certificado asequible de <link xl:href="http://www.rapidsslonline.com">Rapid SSL Online</link> debería ser suficiente para la mayoría de propósitos. Para generar la petición de firma del certificado (CSR, certificate signing request) podemos invocar el comando siguiente. Cuando se nos pregunta por <emphasis role="italic">Common Name</emphasis>, introduciremos el nombre de dominio completo para el sitio web que queremos asegurar.</para>
      <screen>openssl req -new -newkey rsa:2048 -nodes -keyout server.key -out server.csr</screen>
      <para>Una vez tenemos nuestros ficheros de certificado (.pem y .key) necesitaremos colocarlos en una ubicación que sea accesible por nginx. Una buena ubicación para esto puede ser el mismo directorio donde se encuentra el fichero nginx.conf.</para>
      <para>A continuación se muestra un bloque de un servidor nginx donde los ficheros de certificado son server.crt y server.key. Dado que las conexiones SSL generalmente aparecen en el puerto 443 (HTTPS), pasamos las peticiones de ese puerto (443) a la instancia DHIS que está funcionando en <emphasis role="italic">http://localhost:8080</emphasis>. El primer bloque de servidor reescribirá todas las peticiones que conectan al puerto 80 y forzará el uso de HTTPS/SSL. Debemos recordar reemplazar <emphasis role="italic">&lt;server-ip&gt;</emphasis> con la IP de nuestro servidor. Estos bloques deberán reemplazar el bloque que vimos en la sección anterior.</para>
      <screen><![CDATA[# Rewrite block to force use of SSL

server {
  listen     80;
  rewrite    ^ https://<server-ip>$request_uri? permanent;
}

# SSL server block

server {
  listen               443;
  client_max_body_size 10M;

  ssl                  on;
  ssl_certificate      server.crt;
  ssl_certificate_key  server.key;

  ssl_session_timeout  5m;

  ssl_protocols              SSLv2 SSLv3 TLSv1;
  ssl_ciphers                HIGH:!aNULL:!MD5;
  ssl_prefer_server_ciphers  on;

  # Root points to your DHIS webapp location, update it!

  location ~ (\.js$|\.css$|\.gif$|\.woff$|\.ttf$|\.eot$|^/images/|^/icons/|^/dhis-web-commons/.*\.png$) {
    root     /home/dhis/tomcat/webapps/ROOT;
    expires  4d;
  } 

  location / {
    proxy_pass        http://localhost:8080/;
    proxy_redirect    off;
    proxy_set_header  Host            $host;
    proxy_set_header  X-Real-IP       $remote_addr;
    proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
 }
}]]></screen>
    </section>
    <section>
      <title>Scripts de control para nginx</title>
      <para>En determinadas situaciones puede suceder que un servidor se reinicie inesperadamente. Por eso es preferible que Tomcat y nginx arranquen automáticamente cuando el servidor arranca. Para lograr esto, lo primero es crear scripts de inicialización: <emphasis role="italic"> init</emphasis>. Crearemos un fichero nuevo llamado <code>tomcat</code> y pegaremos en él el contenido que se muestra a continuación (es importante que ajustemos la variable HOME a nuestro entorno):</para>
      <screen>#!/bin/sh
#Tomcat init script

HOME=/home/dhis/tomcat/bin

case $1 in
start)
        sh ${HOME}/startup.sh
        ;;
stop)
        sh ${HOME}/shutdown.sh
        ;;
restart)
        sh ${HOME}/shutdown.sh
        sleep 5
        sh ${HOME}/startup.sh
        ;;
esac
exit 0</screen>
      <para>Crearemos también un nuevo fichero llamado <code>nginx</code> y pegaremos en él el contenido siguiente:</para>
      <screen>#!/bin/sh
#nginx init script

DAEMON=/usr/local/nginx/sbin/nginx

case $1 in
start)
        start-stop-daemon --start --exec $DAEMON
        ;;
stop)
        start-stop-daemon --stop --exec $DAEMON
        ;;
restart)
        start-stop-daemon --stop --exec $DAEMON
        sleep 1
        start-stop-daemon --start --exec $DAEMON
        ;;
esac
exit 0</screen>
      <para>Moveremos ambos scripts al directorio de scripts <emphasis role="italic"> init</emphasis> y los convertiremos en ejecutables invocando:</para>
      <screen>sudo mv tomcat nginx /etc/init.d
sudo chmod +x /etc/init.d/nginx /etc/init.d/tomcat</screen>
      <para>A continuación comprobaremos que los scripts serán invocados durante el encendido y apagado del sistema:</para>
      <screen>sudo /usr/sbin/update-rc.d -f nginx defaults 80
sudo /usr/sbin/update-rc.d -f tomcat defaults 81</screen>
      <para>Ahora Tomcat y nginx se iniciarán cuando el servidor arranque y se detendrán cuando el sistema se apague. Si posteriormente necesitamos revertir esto, podremos reemplazar <code>defaults</code> por <code>remove</code> e invocar los comandos anteriores de nuevo.</para>
    </section>
    <section>
      <title>Colocar recursos disponibles con nginx</title>
      <para><emphasis role="bold">Hacer los recursos disponibles públicamente</emphasis></para>
      <para>En algunos escenarios es deseable que determinados recursos estén disponibles públicamente en la Web sin necesidad de autenticación. Un ejemplo de esto es cuando queremos poner recursos del API Web relacionados con el análisis de datos disponibles en un portal Web. El siguiente ejemplo permitirá acceso a gráficas, mapas, reportes, tablas de reportes y recursos de documentos mediante una autenticación básica e insertando una cabecera HTTP de <emphasis role="italic">Autorización</emphasis> en la petición. Esto eliminará la cabecera de "Cookie" de la petición y la cabecera "Set-Cookie" de la respuesta para evitar cambiar el usuario logueado actualmente. Es recomendable crear un usuario específico para este fin, al que demos solo las mínimas autorizaciones requeridas. El valor de Autorización puede construirse codificando en Base64 el nombre de usuario seguido de dos puntos y de la contraseña, y anteponiendo "Basic" a todo, concretamente &quot;Basic base64_encode(username:password)&quot;. De este modo chequeará el método HTTP utilizado para las peticiones y devolverá <emphasis role="italic">405 Método no permitido</emphasis> si detecta algo diferente de GET.</para>
      <screen>location ~ ^/api/(charts|maps|reports|reportTables|documents)/ {
  if ($request_method != GET) {
    return 405;
  }

  proxy_pass        http://localhost:8080;
  proxy_redirect    off;
  proxy_set_header  Host              $host;
  proxy_set_header  X-Real-IP         $remote_addr;
  proxy_set_header  X-Forwarded-For   $proxy_add_x_forwarded_for;
  proxy_set_header  Authorization     &quot;Basic YWRtaW46ZGlzdHJpY3Q=&quot;;
  proxy_set_header  Cookie            &quot;&quot;;
  proxy_hide_header Set-Cookie;
}</screen>
    </section>
    <section>
      <title>Configuración básica de proxy inverso con Apache</title>
      <para>El servidor Apache HTTP es el más común. </para>
      <important>
        <para>Utilizar nginx es la opción preferida de proxy inverso con DHIS2 y no deberíamos tratar de instalar nginx y Apache en el mismo servidor. Si hemos instalado nginx deberemos ignorar esta sección.</para>
      </important>
      <para>El servidor Apache HTTP es el tipo de servidor HTTP más utilizado en la actualidad. Dependiendo de la naturaleza exacta de nuestro despliegue, puede que necesitemos usar Apache como proxy inverso en nuestro servidor DHIS2. En esta sección describiremos cómo implementar una configuración sencilla de proxy inverso con Apache.</para>
      <para>Primero necesitamos instalar unos pocos módulos de programas para Apache y habilitarlos.</para>
      <para><screen>sudo apt-get install apache2 libapache2-mod-proxy-html libapache2-mod-jk
a2enmod proxy proxy_ajp proxy_connect</screen></para>
      <para>Definiremos un conector AJP que el servidor Apache HTTP utilizará para conectarse con Tomcat. El fichero <filename>server.xml</filename> de Tomcat debería estar ubicado en el directorio /conf/ de nuestra instalación Tomcat. Tendremos que asegurarnos de que esta línea no está comentada (podemos fijar el puerto a donde queramos que esté libre):</para>
      <para><screen>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
</screen>Ahora, necesitamos hacer los ajustes en el servidor Apache HTTP que generará respuestas en el puerto 80 y las pasará al servidor Tomcat a través de un conector AJP. Editaremos el fichero <filename>/etc/apache2/mods-enabled/proxy.conf</filename> de modo que se asemeje al ejemplo siguiente. Nos aseguraremos de que el puerto definido en el fichero de configuración coincide con el de Tomcat.</para>
      <para><screen>&lt;IfModule mod_proxy.c&gt;

ProxyRequests Off
ProxyPass /dhis  ajp://localhost:8009/dhis
ProxyPassReverse /dhis  ajp://localhost:8009/dhis

&lt;Location &quot;/dhis&quot;&gt;
  Order allow,deny
  Allow from all
&lt;/Location&gt;     
&lt;/IfModule&gt;
</screen></para>
      <para>ahora podemos reiniciar Tomcat y el servidor Apache HTTP, y entonces nuestra instancia DHIS2 está accesible en http://<emphasis>miservidor</emphasis>/dhis donde <emphasis>miservidor</emphasis> es el nombre de dominio de nuestro servidor. </para>
    </section>
    <section>
      <title>Balanceo de carga básico con Apache y Tomcat</title>
      <para>El balanceo de carga puede emplearse para distribuir la carga del sistema de forma más equilibrada entre las múltiples instancias de Tomcat, en situaciones en las que el tráfico de los usuarios es demasiado grande para ser cubierta por una sola instancia de servidor. En este ejemplo, crearemos una arquitectura sencilla balanceada utilizando &quot;sticky sessions&quot; para distribuir a los usuarios entre dos instancias de Tomcat. </para>
      <para>En primer lugar, necesitamos al menos dos instancias de Tomcat ejecutando DHIS2, que estén conectadas a la misma base de datos. Hay varias arquitecturas posibles, como ejecutar los servidores de aplicación (Tomcat) en máquinas separadas (virtuales) conectadas a un único servidor de bases de datos, o como ejecutar múltiples instancias de Tomcat y una base de datos en una máquina de gran capacidad en situaciones en las que no hay problemas de entrada/sailda, pero cuando el uso de CPU de una instancia de Tomcat limita el rendimiento total del sistema. En este escenario, configuraremos para conectar dos instancias Tomcat funcionando en la misma máquina con una única base de datos mediante un proxy inverso balanceado. Apache se ocupará de los detalles de definir qué instancia de Tomcat responde a cada cliente particular.</para>
      <para>El primer paso es configurar nuestras instancias Tomcat. Las secciones previas han detallado cómo podemos hacer esto. Es importante recordar que ambas instancias Tomcat deberían estar configuradas para utilizar el mismo servidor de base de datos. Algunas modificaciones necesitan hacerse en el fichero server.xml para cada instancia de Tomcat, que se utilizará para identificar de forma única cada instancia. Deberíamos extraer dos copias de Tomcat en el directorio que escojamos. Modificaremos el fichero server.xml de modo que las líneas siguientes sean únicas para cada instancia: </para>
      <para><screen>&lt;Server port=&quot;<emphasis>800<emphasis>5</emphasis></emphasis>&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
...
&lt;Connector port=<emphasis>&quot;8009</emphasis>&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8444&quot; /&gt;
...

&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;<emphasis>jvm1</emphasis>&quot;&gt;</screen></para>
      <para>Aquí los parámetros importantes son el puerto de servidor, el puerto de conector AJP, y el identificador <parameter>jvmRoute</parameter>. El identificador <parameter>jvmRoute</parameter> se adjuntará al JSESSIONID de manera que Apache sabrá qué instancia de Tomcat debe ser enrutada a una sesión concreta. Los parámetros deben ser únicos para cada instancia de Tomcat. Después de configurar Tomcat, montaremos DHIS2 de acuerdo al procedimiento normal explicado en otras secciones de este manual.</para>

      <para>A continuación, configuraremos el servidor Apache HTTP para realizar balanceo de carga. Las peticiones entrantes de clientes se asignarán a una de las instancias con una sticky session. Modificamos el fichero <filename>/etc/apache2/apache2.conf </filename> (u otro fichero apropiado dependiendo de nuestra configuración exacta) para difinir un proxy balanceador de carga y una ruta de proxy y de proxy inverso. Notemos que los números de puerto y los parámetros de <parameter>route</parameter> deben coincidir con el puerto Tomcat y los parámetros <parameter>jvmRoute</parameter> que definimos anteriormente en la configuración de Tomcat.</para>
      <screen>&lt;Proxy balancer://dhiscluster&gt;
Order Allow,Deny
Allow from all
&lt;/Proxy&gt;

&lt;Proxy balancer://dhiscluster&gt;
BalancerMember ajp://127.0.0.1:8009/dhis route=dhis1
BalancerMember ajp://127.0.0.1:9009/dhis route=dhis2

ProxySet lbmethod=byrequests
ProxySet stickysession=JSESSIONID
&lt;/Proxy&gt;

ProxyVia Off
ProxyPass /dhis/ balancer://dhiscluster/ stickysession=JSESSIONID nofailover=on

ProxyPassReverse /dhis/ balancer://dhiscluster/ stickysession=JSESSIONID|jsessionid
</screen>
      <para>Finalmente, arrancaremos ambas instancias Tomcat, y reiniciaremos el Apache HTTP. </para>
      <para>Este ejemplo demuestra cómo implementar un sistema sencillo de balanceo de carga con sticky sessions utilizando un servidor Apache HTTP.</para>
    </section>
    <section>
      <title>Encriptado básico SSL con Apache</title>
      <para>Utilizando Apache y el montaje de proxy inverso definido en la sección anterior, podemos implementar fácilmente transferencias encriptadas de datos entre los clientes y el servidor sobre HTTPS. Esta sección describe cómo usar certificados autofirmados, aunque el mismo procedimiento podría servir también si tenemos certificados firmados por terceros.</para>
      <para>Primero (como root), generaremos los ficheros de claves privadas necesarios y la Petición de Firma de Certificado (CSR, Certificate Signing Request). </para>
      <screen>mkdir /etc/apache2/ssl
cd /etc/apache2/ssl
openssl genrsa -des3 -out server.key 1024
openssl req -new -key server.key -out server.csr</screen>
      <para>Necesitaremos eliminar la contraseña de la clave, ya que si no lo hacemos Apache no será capaz de usarla. </para>
      <para><screen>cp server.key server.key.org
openssl rsa -in server.key.org -out server.key</screen></para>
      <para>A continuación, generamos un certificado autofirmado que será válido por un año.</para>
      <screen>openssl x509 -req -days 365 -in server.csr -signkey \ server.key -out server.crt</screen>
      <para>ahora, configuraremos Apache habilitando los módulos SSL y creando un sitio por defecto.</para>
      <screen>a2enmod ssl
a2ensite default-ssl</screen>
      <para>Ahora, necesitamos editar el fihero SSL por defecto (ubicado en <filename>/etc/apache2/sites-enabled/default-ssl</filename>) para habilitar la funcionalidad de transferencias SSL en Apache.</para>
      <para><screen>&lt;VirtualHost *:443&gt;
        ServerAdmin wemaster@mydomain.org
       SSLEngine On
       SSLCertificateFile /etc/apache2/ssl/server.crt
       SSLCertificateKeyFile /etc/apache2/ssl/server.key
...</screen></para>
      <para>Nos aseguraremos de cambiar la sección *:80 de este fichero al puerto *:443, que es el puerto SSL utilizado por defecto. También, comprobaremos el cambio de ServerAdmin por el email del webmaster. Finalmente, tendremos que asegurarnos de que el hostname está correctamente indicado en /etc/hosts. Simplemente, bajo la línea de localhost, añadiremos la dirección IP del servidor y el nombre de dominio. </para>
      <para><screen>127.0.0.1 localhost
XXX.XX.XXX.XXX foo.mydomain.org</screen></para>
      <para>Ahora, reiniciaremos Apache:</para> 
      <screen>/etc/init.d/apache2 restart</screen>
      <para>Y deberíamos ser capaces de ver https://foo.mydomain.org/dhis. </para>
    </section>
  </section>
  <section>
    <title>Instalación de DHIS 2 Live</title>
    <para>El paquete DHIS 2 Live es muy cómodo de instalar y ejecutar. Está pensado para ejemplos demostrativos, para usuarios que quieren explorar el sistema y para instalaciones pequeñas, offline típicamente en distritos o establecimientos de salud. Solo requiere el Entorno de Ejecución de Java (Java Runtime Environment) y funciona en todos los navegadores web excepto Internet Explorer 7 o versiones anteriores.</para>
    <para>Para instalarlo comenzaremos descargando DHIS 2 Live de la página <emphasis role="italic">http://dhis2.org</emphasis> y extrayendo el archivo en alguna ubicación. En Windows pincharemos en el archivo ejecutable. En Linux invocamos el script <code>startup.sh</code> </para>
    <para>Después del proceso de arranque, nuestro navegador web por defecto estará apuntando automáticamente a <emphasis role="italic">http://localhost:8082</emphasis>, donde se encuentra la aplicación. En la mayoría de sistemas operativos aparecerá un menú de sistema donde podremos arrancar y detener el servidor, así como iniciar nuevas sesiones de navegador. Notemos que si el servidor está funcionando no hay necesidad de arrancarlo de nuevo, sino simplemente abrir la aplicación desde el menú de sistema.</para>
    <para>DHIS 2 Live se ejecuta en un contenedor Servlet Jetty embebido y con una base de datos H2 embebida. Sin embargo, podremos configurarlo para funcionar con otros sistemas de bases de datos como PostgreSQL. Encontraremos una explicación detallada sobre la configuración de una base de datos en la sección anterior sobre instalación en servidor. El fichero de configuración <emphasis role="italic">hibernate.properties</emphasis> se encuentra en la carpeta <emphasis role="italic">conf</emphasis>. Es importante acordarnos de reiniciar el paquete Live para que los cambios tengan efecto. El puerto del servidor es 8082 por defecto. Esto también podemos cambiarlo modificando el valor correspondiente en el fichero de configuración<emphasis role="italic"> jetty.port</emphasis> que se encuentra en el directorio <emphasis role="italic">conf</emphasis>.</para>
  </section>
  <section>
    <title>Copias de seguridad (Backup)</title>
    <para>Es indispensable hacer copias de seguridad automatizadas de las bases de datos de sistemas de información en producción. Ignorar esto puede traer consecuencias desagradables. Las copias de seguridad tienen dos propósitos principales: el primero es la recuperar los datos en caso de que suceda una pérdida de datos, el segundo es archivar los datos durante un periodo de tiempo histórico.</para>
    <para>Las copias de seguridad son fundamentales en un plan de recuperación del desastre. Incluso cuando un plan como este debería cubrir también otros asuntos, la base de datos es el componente clave a considerar porque es ahí donde se guardan todos los datos utilizados en la aplicación DHIS 2. Las otras partes de la infraestructura TIC en torno a la aplicación se pueden restaurar en base a componentes estándar.</para>
    <para>Por supuesto hay muchas maneras de configurar copias de seguridad; sin embargo, a continuación describimos una configuración donde la base de datos se copia en un fichero dump y se guarda en el sistema de ficheros. Esto puede considerarse una copia de seguridad <emphasis role="italic">completa</emphasis>. La copia de seguridad se realiza con el <emphasis role="italic">cron</emphasis>, que es un programador temporal en los sistemas operativos Unix/Linux.</para>
    <remark>Podemos descargar ambos ficheros de la página http://dhis2.com/download/pg_backup.zip</remark>
    <para>El cron se configura con dos ficheros. El primero es un <emphasis role="italic">script</emphasis> de backup que realiza la tarea misma de hacer la copia de seguridad de la base de datos. Utiliza un programa PostgreSQL llamado <emphasis role="italic">pg_dump</emphasis> para crear la copia de la base de datos. El segundo es un fichero crontab que lanza el script de backup cada día a las 23:00. Notemos que este script hace la copia de seguridad de la base de datos y la guarda en un fichero en el disco local. Es muy recomendable guardar una copia de esto también fuera del servidor donde se aloja la aplicación. Esto podemos conseguirlo con la herramienta <emphasis role="italic">scp</emphasis>. Deberemos asegurarnos de que hemos fijado la fecha y hora del sistema correctamente en nuestro servidor.</para>
  </section>
  <section>
  <title>Trabajando con la base de datos PostgreSQL</title>
    <para>Algunas operaciones frecuentes al gestionar una instancia DHIS son las copias y restauraciones de bases de datos. Para realizar una copia (dump) de nuestra base de datos, asumiendo la configuración mencionada en la sección de instalación, podemos invocar lo siguiente: </para>
    <screen>pg_dump dhis2 -U dhis -f dhis2.sql</screen>
    <para>El primer argumento (dhis2) se refiere al nombre de la base de datos. El segundo argumento (dhis) se refiere al usuario de la base de datos. El último argumento (dhis2.sql) es el nombre de fichero de la copia. Si queremos comprimir el fichero copiado inmediatemente podemos hacer lo siguiente:</para>
    <screen>pg_dump dhis2 -U dhis | gzip > dhis2.sql.gz</screen>
    <para>Para restaurar esta copia en otro sistema, primero necesitamos crear una base de datos vacía como se describe en la sección de instalación. También necesitamos descomprimir la copia si habíamos creado una versión comprimida. Podemos invocar entonces:</para>
    <screen>psql -d dhis2 -U dhis -f dhis2.sql</screen>
  </section>
  <section>
    <title>Usando los Servicios Web Amazon</title>
    <para>Los Servicios Web Amazon (AWS) ofrecen recursos virtuales de cloud-computing que permiten a desarrolladores e implementadores escalar rápidamente una aplicación, tanto horizontal como verticalmente, de forma eficaz en cuanto a costes. AWS ofrece múltiples sistemas operativos y tamaños de instancias dependiendo de la naturaleza concreta del despliegue. Esta sección descrie un montaje sencillo con el sistema AWS Elastic Cloud Compute (EC2) utilizando Amazon AMI Basic 32 bit, que se basa en la distribución Red Hat Linux. </para>
    <para>Podemos estimar el coste de una instancia AWS usando el <link xl:href="http://calculator.s3.amazonaws.com/calc5.html"> &quot;Simple Monthly Calculator&quot;</link>. Los costes de AWS se basan directamente en su uso. A medida que crece el uso de nuestra aplicación, podemos proveer con nuevos servidores. </para>
    <orderedlist>
      <listitem>
        <para>Necesitaremos una cuenta AWS existente. Si aún no tenemos una, podemos crearla <link xl:href="http://aws.amazon.com/">aquí</link>.  Una vez hayamos creado y habilitado nuestra cuenta, nos logueamos en <link xl:href="https://console.aws.amazon.com/s3/home"> la consola AWS</link>. </para>
      </listitem>
      <listitem>
        <para>Cuando estemos logueados, seleccionamos la pestaña &quot;EC2&quot;. A continuación, seleccionamos una región donde instanciar nuestra instancia. Los usuarios en Europa y África, probablemente podrán usar la región EU West, mientras usuarios en Asia deberán usar probablemente la de regiones Asia Pacífico (sea Singapur o Tokio), y los usuarios de Latinoamérica dberán usar la región de las Américas. La selección de la región apropiada reducirá la latencia entre servidor y clientes.</para>
      </listitem>
      <listitem>
        <para>Haremos click en el enlace de &quot;Instancias&quot; en el menú de la derecha, y luego en el botón &quot;Lanzar Instancias&quot;. </para>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata width="60%" align="center" fileref="resources/images/aws/create_instance.png"/>
            </imageobject>
          </mediaobject>
        </screenshot>
        <para>Seleccionamos uno de los AMIs para nuestro servidor. Es recomendable usar cualquiera de los AMIs básicos de Amazon (sea el de 32 ó 64 bits), pero podemos elegir el AMI que sea más adecuado en nuestro caso.</para>
      </listitem>
      <listitem>
        <para>A continuación necesitaremos seleccionar el tamaño de nuestra instancia. El tamaño seleccionado dependerá del número de usuarios anticipados. Seleccionar el tamaño &quot;Micro&quot; nos permitirá probar DHIS 2 en el entorno AWS durante un periodo de un año, sin coste si usamos uno de los AMIs&quot;Free tier eligible&quot;. </para>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata width="60%" align="center" fileref="resources/images/aws/instance_size.png"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </listitem>
      <listitem>
        <para>Cuando hayamos seleccionado el tamaño de instancia, podremos seleccionar un ID específico de kernel y de disco RAM. Si no tenemos un criterio en particular, simplemente usamos los valores por defecto y seguimos al siguiente paso.</para>
      </listitem>
      <listitem>
        <para>A continuación, añadimos las parejas de claves para facilitarnos la identificación de la instancia. Esto son simplemente metadatos para nuestro propio manejo. </para>
      </listitem>
      <listitem>
        <para>Ahora necesitaremos una pareja de claves que nos permita acceder remotamente a nuestra instancia. Si tenemos una pareja de claves ya creada podemos usarla, si no, podemos crear una nueva. </para>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata width="60%" align="center" fileref="resources/images/aws/create_key_pairs.png"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </listitem>
      <listitem>
        <para>Pasaremos a asignar un grupo de seguridad a la instancia. Los grupos de seguridad se pueden usar para exponer ciertos servicios (SSH, HTTP, Tomcat, etc) en Internet. Con grupos de seguridad, podemos controlar qué puertos se abrirán a ciertos rangos de red. Para DHIS 2, normalmente necesitaremos abrir al menos el puerto 22 (SSH) y el puerto 80 (HTTP) a Internet o a rangos de direcciones específicos. </para>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata width="50%" align="center" fileref="resources/images/aws/security_groups.png"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </listitem>
      <listitem>
        <para>Finalmente, podremos revisar y lanzar nuestra instancia. </para>
      </listitem>
      <listitem>
        <para>Una vez hemos lanzado la instancia, podremos conectarnos via PuTTY o cualquier cliente SSH a la instancia utilizando el DNS público de la misma, que aparece listado en el panel de control de EC2. Necesitaremos instalar unos cuantos paquetes si estamos usando el AMI por defecto de Amazon.</para>
        <screen>yum install jdk.i586 postgresql-server.i686 apache-tomcat-apis.
noarch tomcat-native.i686 httpd.i686</screen>
      </listitem>
      <listitem>
        <para>Cuando hayamos instalado estos paquetes, podremos seguir las instrucciones detalladas en la sección 8.1 de Montaje de un servidor.</para>
      </listitem>
    </orderedlist>
  </section>
</chapter>
